CS122 Assignment 2 - SQL Planning and Joins - Design Document
=============================================================

A:  Logistics
-------------

A1.  List your team name and the people who worked on this assignment.

     nanodb-ddj

     Daniel Kong
     Daniel Wang
     Jerry Zhang

A2.  Specify the tag name and commit-hash of the Git version you are
     submitting for your assignment.  (You can list the commit hashes
     of your repository tags with this command:  git show-ref --tags)

     Tag name:     <tag>
     Commit hash:  <hash>

A3.  Specify any late tokens you are applying to this assignment, or
     "none" if no late tokens.
     none

A4.  Briefly describe what parts of the assignment each teammate focused on.
     Daniel Kong: grouping and aggregation
     Daniel Wang: non-grouping plan nodes
     Jerry Zhang: Nested loop join and tests

B:  Simple Planner
------------------

B1.  Without going into the details of how you handle grouping and
     aggregation or joins, list the general sequence of steps that your
     planner's makePlan() method follows to translate a SQL query into
     an execution plan.
First, we examine the from clause of the query and generate a plan tree from
that. We add a WHERE predicate if one exists, then handle grouping and
aggregation. We then add HAVING clauses, nontrivial project, and sorting,
if necessary. Finally, the plan is prepared and returned.

B2.  Describe how you generate the execution-plan fragment for the query's
     FromClause.  Make sure to touch on what you do in the three cases your
     planner is expected to handle - tables, subqueries in the FROM clause,
     and joins.
For base tables, we create a filescan node with no predicate, then attach
a rename node if needed. This is less efficient than the makeSimpleSelect,
since predicates are added after scanning the whole file, rather than
during the file scan.

For subqueries, we recursively call the fromClauseToNode function, renaming
the result (since all derived relations must have an alias).

For joins, we first check if USING or NATURAL joins occur. If so, we indicate
that an additional project node is needed to get rid of duplicate columns.
Right outer joins also require an additional project and a conversion to
left outer join. Semi/antijoins are a special case and do not require project
regardless of the predicate, so we check for that and update the project
flag as necessary. Finally, we get the left/right children and the predicate
and perform the join, appending a project node if the flag indicates.

B3.  Describe how you implemented support for grouping and aggregation.
     Be sure to note any variations from the approach outlined in class,
     if there are any.

We basically followed the approach suggested in class/in the assignment. For
grouping and aggregation, we created an AggregateProcessor class (that
implements ExpressionProcessor) that we use to traverse Expression trees. It
scans for aggregate functions, and then replaces them with an autogenerated
name #AX that increments with each function found. The autogenerated column
names are then mapped to FunctionCall objects, which are executed when the
GroupAggregateNode is executed. We use the HashedGroupAggregateNode as the
implementation of GroupAggregateNode for grouping and aggregation.

As suggested, we scan the FROM and WHERE claused for aggregate functions and
throw exceptions if any are found. Exceptions are also thrown if nested
aggregate functions are found (we keep track of this by setting a flag in the
enter() method and resetting it in the leave() method).

B4.  Does your planner try to implement any simplifications in specific
     circumstances, e.g. when a "trivial project" is used (i.e. "SELECT *
     FROM ...") in your planner?  Briefly enumerate simplifications and
     optimizations here.
We ignore any trivial projects such as SELECT *.

C:  Nested-Loop Join
--------------------

C1.  The join algorithm stated in class is really only suitable for
     materialized evaluation, where the entire result is generated by the
     algorithm.  It is completely unsuitable for pipelined evaluation,
     where results are generated row by row.

     Summarize how your implementation works for inner joins, using
     pseudocode to show how rows are considered and returned as the
     algorithm executes, and what state must be saved so that the
     operation can resume at the appropriate place when the next row
     must be returned.

For inner joins, the current left and right tuple are stored as part of the node's state.

The pseudocode is basically :
def getNextTuple():
    if done return null
    while (getTuplesToJoin()):
        if (canjoinTuples()) return join(leftTuple, rightTuple)
    return null

def getTuplesToJoin():
    moveForward(rightTuple)
    if rightTuple == null:
        moveForward(leftTuple)
        if leftTuple == null:
            done = true
            return false
        resetAndMoveForward(rightTuple)
    return true

The getNextTuple retrieves tuples as long as there are tuples available. If the tuples can be
joined, it returns the joined tuples. The state is saved so the next time it is called,
scanning continues from the same exact point. getTuplesToJoin simulates a double nested for
loop by moving the right tuple forward one, then if the right tuple reaches the end, moving
the left tuple forward one and resetting the right tuple.

C2.  What tweaks did you need to introduce into the implementation for
     left outer joins?  Keep your answer brief, but please also be specific.

For left outer joins, as well as for anti joins, the state keeps a matched boolean
which is true if the current left tuple has at any point been joined and returned. The
getTuplesToJoin function uses this by checking if it is a left outer join once the end
of the right tuples is reached. If it is and the left tuple has not been matched,
then it returns the left tuple with a null right tuple. getNextTuple takes this into
account by checking if the right tuple is null, and if so, replacing it with a premade tuple
of nulls that is the same width as the right schema.

C3.  Same question as for C2, but for semijoins.

For semi joins, the only difference from inner joins is that when the left and right tuples
match, then only the left tuple is returned rather than joining them, and the left tuple is
moved forward and the right tuple reset before it is returned.

C4.  Same question as for C2, but for antijoins.

For anti joins, the matched boolean is also used. If tuples can be joined, matched is set to
true but nothing is returned. Instead, when getTuplesToJoin reaches the end of the right
tuples, it checks if this is an antijoin and if so and the left tuple has not been matched,
it returns the left tuple with null. When getNextTuple sees a null right tuple, only then does
it return the left tuple.

C5.  Enumerate your nested-loop join test cases, following this form:

     * <test-case class name>.<test function>
       <brief one-sentence description of what the test exercises>

 * TestSimpleJoins.testCrossJoin
Tests cross joins of tables where one, none, and both are empty.

 * TestSimpleJoins.testLeftOuterJoin
Tests left outer joins of tables where one, none, and both are empty. The predicate is
an ON clause with a common variable.

 * TestSimpleJoins.testRightOuterJoin
Tests right outer joins of tables where one, none, and both are empty. The predicate is
an ON clause with a common variable.

 * TestSimpleJoins.testInnerJoin
Tests inner joins of tables where one, none, and both are empty. The predicate is
an ON clause with a common variable.

D:  Extra Credit [OPTIONAL]
---------------------------

If you implemented any extra-credit tasks for this assignment, describe
them here.  The description should be like this, with stuff in "<>" replaced.
(The value i starts at 1 and increments...)

D<i>:  <one-line description>

     <brief summary of what you did, including the specific classes that
     we should look at for your implementation>

     <brief summary of test-cases that demonstrate/exercise your extra work>

D1: Tests for Using and Natural Joins

    In TestUsingJoins.java and TestNaturalJoins.java, there are tests for joins
    involving the USING and NATURAL statements. The tests are very similar to
    those for testSimpleJoins.


E:  Feedback [OPTIONAL]
-----------------------

These questions are optional, and they obviously won't affect your grade
in any way (including if you hate everything about the assignment and
databases in general, or Donnie and the TAs in particular).

NOTE:  If you wish to give anonymous feedback, a similar survey will be
       made available on the Moodle.

E1.  How many hours total did your team spend on this assignment?
     (That is, the sum of each teammate's time spent on the assignment.)

E2.  What parts of the assignment were most time-consuming?

E3.  Which parts of the assignment did you particularly enjoy?

E4.  Which parts did you particularly dislike?

E5.  Do you have any suggestions for how future versions of the
     assignment can be improved?

